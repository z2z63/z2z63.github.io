

<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title>Week1 - Virtualfutre&#39;s Blog</title><meta name="Description" content=""><meta property="og:url" content="http://example.org/posts/week1/">
  <meta property="og:site_name" content="Virtualfutre&#39;s Blog">
  <meta property="og:title" content="Week1">
  <meta property="og:description" content="最近关于博客的内容考虑了很多，怎样让博客的内容更有价值、怎样输出内容等等。也考虑了未来如果内容做好了，可以开始做SEO等等。因为我认为博客还">
  <meta property="og:locale" content="zh_CN">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-17T19:36:40+08:00">
    <meta property="article:modified_time" content="2024-06-17T19:36:40+08:00">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Week1">
  <meta name="twitter:description" content="最近关于博客的内容考虑了很多，怎样让博客的内容更有价值、怎样输出内容等等。也考虑了未来如果内容做好了，可以开始做SEO等等。因为我认为博客还">
<meta name="application-name" content="Virtualfutre&#39;s Blog">
<meta name="apple-mobile-web-app-title" content="Virtualfutre&#39;s Blog">

<meta name="theme-color" content="#f8f8f8"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="canonical" href="http://example.org/posts/week1/" /><link rel="prev" href="http://example.org/posts/browser_tricks/" /><link rel="next" href="http://example.org/posts/week2/" />
<link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/color.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.css">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.css">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.css"></noscript><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "Week1",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/posts\/week1\/"
        },"genre": "posts","wordcount":  5405 ,
        "url": "http:\/\/example.org\/posts\/week1\/","datePublished": "2024-06-17T19:36:40+08:00","dateModified": "2024-06-17T19:36:40+08:00","publisher": {
            "@type": "Organization",
            "name": "z2z63"},"author": {
                "@type": "Person",
                "name": "z2z63"
            },"description": ""
    }
    </script><script src="//instant.page/5.2.0" defer type="module" integrity="sha384-jnZyxPjiipYXnSU0ygqeac2q7CVYMbh84q0uHVRRxEtvFPiQYbXWUorga2aqZJ0z"></script>
</head>

<body header-desktop="" header-mobile=""><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme); document.documentElement.style.setProperty('color-scheme', theme === 'light' ? 'light' : 'dark'); window.theme = theme;   window.isDark = window.theme !== 'light' }
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('' === 'light' || '' === 'dark' || '' === 'black') setTheme(''), saveTheme(''); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
        window.switchThemeEventSet = new Set()
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Virtualfutre&#39;s Blog">Virtualfutre&#39;s Blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> Posts </a><a class="menu-item" href="/tags/"> Tags </a><a class="menu-item" href="/categories/"> Categories </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Virtualfutre&#39;s Blog">Virtualfutre&#39;s Blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">Posts</a><a class="menu-item" href="/tags/" title="">Tags</a><a class="menu-item" href="/categories/" title="">Categories</a><a href="javascript:void(0);" class="menu-item theme-switch" title="Switch Theme">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">Contents</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents"></nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">Week1</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><span class="author fas fa-user-circle fa-fw"></span><a href="/" title="Author" rel=" author" class="author">z2z63</a>
                </span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2024-06-17">2024-06-17</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="2024-06-17">2024-06-17</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;5405 words&nbsp;<i class="far fa-clock fa-fw"></i>&nbsp;11 minutes&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>Contents</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents"></nav></div>
            </div><div class="content" id="content"><p>最近关于博客的内容考虑了很多，怎样让博客的内容更有价值、怎样输出内容等等。也考虑了未来如果内容做好了，可以开始做SEO等等。因为我认为博客还是一种比较轻松的阅读内容，如果选择输出干货，一来读者不一定了解这方面的知识，二来读者如果非常了解这方面的知识，这篇文章也没有价值；如果想加深对某领域的了解，完全可以看一些经典的书籍，他们的内容比博客好多了，于是我决定改变博客的内容。希望我的博客是启发性的，读者看完后能够对某个小领域有个大致的理解，或者看完后产生兴趣，去阅读更专业的书籍、文档等等。换而言之以后的文章相比深度更倾向广度，比起话题更想随谈。另外我能力也不足以输出深度足够的文章。</p>
<h1 id="外部归并排序" class="headerLink">
    <a href="#%e5%a4%96%e9%83%a8%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f" class="header-mark"></a>外部归并排序</h1><p>最近打数据库比赛，我负责的一道题是归并连接
<figure><a class="lightgallery" href="https://raw.githubusercontent.com/z2z63/image/main/202406172000587.png" title="https://raw.githubusercontent.com/z2z63/image/main/202406172000587.png" data-thumbnail="https://raw.githubusercontent.com/z2z63/image/main/202406172000587.png">
        <img
            
            loading="lazy"
            src="https://raw.githubusercontent.com/z2z63/image/main/202406172000587.png"
            srcset="https://raw.githubusercontent.com/z2z63/image/main/202406172000587.png, https://raw.githubusercontent.com/z2z63/image/main/202406172000587.png 1.5x, https://raw.githubusercontent.com/z2z63/image/main/202406172000587.png 2x"
            sizes="auto"
            alt="https://raw.githubusercontent.com/z2z63/image/main/202406172000587.png">
    </a></figure>
需要使用归并排序算法，准确的说是external merge sort，即在内存有限的情况下，利用外存辅助排序，其核心思想是一种经典的算法：分治法（分而治之，divide-and-conquer）<br>
假设内存只能使用1G（大致范围，不考虑细枝末节），而需要排序10G的记录，归并排序的步骤是</p>
<ol>
<li>将10G内存分十次读取到内存，在内存中完成1G记录的排序（可以使用常见的排序算法，例如快速排序），排序结果写入总共10个文件</li>
<li>将10个文件分别读取一块到内存（假设读取100M，总共使用1000M，没有超过1G限制）</li>
<li>从每块的第一个记录中选择最小的一个，取出，输出（每块中最小的记录肯定是第一个，因为块内已经排好序了）</li>
<li>重复3，如果某块使用完，就从对应文件读取下一块</li>
<li>10个文件的内容全部使用完毕，完成排序</li>
</ol>
<p>算法不难理解，然而实现起来就会遇到各种各样的问题，</p>
<ul>
<li>如果有10.1G的记录，按照上述办法，就会有一个0.1G的文件</li>
<li>如果一块大小是80M，该文件的最后一块就是64M</li>
<li>如果记录只有900M，算法也应该能正常处理，而且最好不使用外存（但在数据库场合下，前一个算子执行时输出多少记录是不可能预先知道的，例如select算子，可以携带where语句的条件，实际输出的记录数量只能确定范围而无法具体知道其数量）</li>
<li>文件应该保存在哪里（放在tmpfs就不满足要求了，因为tmpfs就是使用内存实现的）</li>
<li>文件IO怎么做（直接用<code>read</code>，<code>write</code>系统调用？使用带缓冲的libc？使用<code>mmap</code>？）</li>
</ul>
<p>于是实现这样一个外部归并排序，从最开始的查找资料，理解算法，到选择实现路径，再到动手实现、抽象，重构，分离，加上各种错误处理，考虑各种corner case，已经非常复杂了</p>
<p>另外再考虑使用google test写测试，怎样才能写出一个好的测试，把问题都找出来（自己写测试找bug比写了一堆代码，提测时才发现问题快多了！）</p>
<p>再考虑借鉴一下现成的算法实现，有例如stxxl这样非常全面系统的大数据处理库，也有github上十几颗星星，一两个文件的实现，还有使用其他语言实现的，等等。怎样保证正确的同时控制复杂度，可以看出从理论到实践的差距非常大，实践的内容已经远超理论的内容了，而我理论的内容也只是了解了部分，只能说希望未来的我能轻松做到吧&hellip;</p>
<h1 id="object-header" class="headerLink">
    <a href="#object-header" class="header-mark"></a>object header</h1><p>所谓object header就是一个对象的头部，在许多高级语言中对象都有object header。从理论上也能推导出一定需要一个额外的区域保存一些信息，不一定叫做object header，也可以是object footer</p>
<p>面向对象的一个特点是多态，多态可以理解为子类对象能够完美的嵌入到需要父类的地方，而如何知道该调用父类方法还是子类方法，只能在运行时确定，所以OOP一定要把类型信息带入运行时，这也是OOP的一个overhead（开销）</p>
<p>然而cpp比较特殊，虽然它也是OOP语言，但cpp的大部分（？）对象都是没有object header的，可以做一个简单的实验验证一下
<figure><a class="lightgallery" href="https://raw.githubusercontent.com/z2z63/image/main/202406172054157.png" title="https://raw.githubusercontent.com/z2z63/image/main/202406172054157.png" data-thumbnail="https://raw.githubusercontent.com/z2z63/image/main/202406172054157.png">
        <img
            
            loading="lazy"
            src="https://raw.githubusercontent.com/z2z63/image/main/202406172054157.png"
            srcset="https://raw.githubusercontent.com/z2z63/image/main/202406172054157.png, https://raw.githubusercontent.com/z2z63/image/main/202406172054157.png 1.5x, https://raw.githubusercontent.com/z2z63/image/main/202406172054157.png 2x"
            sizes="auto"
            alt="https://raw.githubusercontent.com/z2z63/image/main/202406172054157.png">
    </a></figure>
我的猜测是，cpp首先favour zero cost abstraction(青睐零开销抽象)，让每个对象仅仅因为OOP的需要就带上一个绝大多数场合下都不会使用的object header，是不可接受的<br>
其次，cpp相比其他传统OOP语言，有很多不同的地方</p>
<ol>
<li>cpp的对象和原始类型不存在鸿沟，反而是可以密切配合的，对象可以轻易取其地址，<code>malloc</code>和<code>new</code>的区别也仅仅是<code>new</code>相比<code>malloc</code>多做了类的构造函数，而传统OOP语言，对象和原始对象存在鸿沟，互操作时需要包装类，例如java需要使用繁琐的wrapper box，而JS会自动完成原始类型和对象的转换</li>
<li>cpp的对象和原始类型可以随意放在堆上或者栈上，而传统OOP则将对象放在堆上而原始类型放在栈上</li>
<li>cpp的多态必须使用指针，并且必须有虚拟类</li>
</ol>
<p>结合以上原因，我猜测也许虚拟类的子类的对象会有类似object header的东西，否则从理论上推导，cpp就无法完成多态了</p>
<h1 id="runtime" class="headerLink">
    <a href="#runtime" class="header-mark"></a>runtime</h1><p>上文出现的两个运行时，分别使用了两个不同的含义。</p>
<ol>
<li>含义一：程序的时态<br>
程序的时态，可以包括开发时，编译时，链接时，装载时，运行时等等，这也是从字面意义上理解runtime</li>
<li>含义二：runtime system的缩写<br>
runtime system提供了程序运行的环境。就算是汇编语言也需要相应的环境才能运行，C的运行时提供以下运行时支持
<ol>
<li>栈<br>
在操作系统启动时就已经准备好了，因为操作系统主要是C编写的，也需要栈的环境</li>
<li>libc<br>
包含C标准定义的函数，有与操作系统交互的函数，也有字符串处理函数</li>
<li>dynamic linker<br>
动态链接器用于将多个目标文件中的代码段，数据段等链接起来，于是在运行时能够调用其他目标文件中的函数，linker完成了elf装载完成后bootstrap的过程，bootstrap先于<code>__start</code>函数的执行，而<code>__start</code>函数先于<code>main</code>函数的执行</li>
<li>多线程支持<br>
例如线程私有变量，线程安全版本的函数，多线程环境下的<code>exit</code></li>
<li>内存分配系统<br>
C标准中提供的<code>malloc</code>系列函数，提供了内置的内存分配系统，用于管理堆区</li>
<li>IO缓冲<br>
libc在操作系统IO操作原语基础上，提供了带缓冲的IO，例如<code>fread</code>,<code>fwrite</code>等等，并提供了三种缓冲选项（无缓冲，行缓冲，全缓冲），用于在大部分场合下，提高应用程序IO速度，并减小开发者心智负担</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong><em>NOTE:</em></strong> 如果对以上内容感兴趣，参见《程序员的自我修养——链接、装载与库》</p>
</blockquote>
<h1 id="exec的极限" class="headerLink">
    <a href="#exec%e7%9a%84%e6%9e%81%e9%99%90" class="header-mark"></a>exec的极限</h1><p>在给上文提及的external merge sort写测试的时候，我最开始使用了非常烂的参数，导致测试程序在一个目录下大量的创建了辅助排序用的文件，它们使用<code>mkstemp</code>创建，模板为<code>aux_sort_fileXXXXXX</code>，<code>mkstemp</code>会自动将末尾的<code>X</code>替换成随机的字母，并创建、打开该文件，这样就不必考虑为文件起一个不会重复的名字</p>
<p>为了删除这些文件，我最开始使用的命令是<code>rm aux*</code>，然而shell报错&quot;Too many arugments&quot;<br>
然后我使用的命令是<code>fd 'aux*' --exec rm {}</code>，<code>fd</code>是<code>find</code>的加强版，这个命令相当于<code>find . -name 'aux*' -exec rm {} \;</code></p>
<p>那么&quot;Too many arugments&quot;是为什么呢？</p>
<p>Linux系统许多地方都是有限制的，例如<code>hostname</code>（主机名）长度不能超过某个值，路径长度不能超过某个值等等，这是因为动态长度的东西很难处理，内核实现中为了简单，往往会规定一个<code>limit</code>，并定义超过<code>limit</code>后的行为（一声不吭？报错？自动截断？）</p>
<p>决定&quot;Too many arugments&quot;的<code>limit</code>是<code>ARG_MAX</code>，即命令行的最长参数长度，因为<code>rm aux*</code>中的<code>*</code>是shell的wildcard（通配符）, shell将<code>aux*</code>替换成所有文件名开头为<code>aux</code>的文件，然后执行命令（内核不会特殊对待<code>*</code>，<code>*</code>是shell层面的feature），当文件特别多时（当时也许有几千或几万个文件），就有可能触发<code>limit</code></p>
<p><code>ARG_MAX</code>起作用的范围是<code>exec</code>系统调用，libc提供的<code>exec</code>系列函数（包括<code>execl</code>,<code>execlp</code>,<code>execle</code>等等）只是<code>exec</code>系统调用的封装，<code>ARG_MAX</code>限制了<code>exec</code>能传入的参数的长度。而shell本质上只是<code>exec</code>系统调用的一个封装，自然也会受到<code>ARG_MAX</code>的限制（参考一些简易shell的实现，只涉及管道，fork，exec）</p>
<p>linux是类unix系统，在unix发展历史上，因为过多vendor(厂商)分别开发和维护自己的unix系统，导致unix分裂，于是若干大头（IEEE，美国政府等）牵头指定了若干标准，有POSIX和Single Unix Specification，它们对以上提及的各种<code>limit</code>都有详细的定义，提倡unix系统提供的<code>limit</code>应该至少大于某个值，即标准规定的至少应该满足的值</p>
<p>此外，POSIX和Signle Unix Specification有若干版本，以及各自的扩展，例如XSI就是POSIX.1的扩展。unix是使用C开发的，C在历史上也有分裂的时期，于是人们也成立ISO/IEC制定了C的标准，这些标准是语言层面的，不会单独为Unix考虑，更多地考虑中立，但也影响了Unix，例如long应该有多长，INT最大值是多少等等</p>
<p>举一些例子说明ISO C, POSIX, Signle Unix Specification如何相互影响</p>
<ol>
<li>
<p>ISO C定义了<code>FILENAME_MAX</code>，但随后POSIX定义了<code>NAME_MAX</code>和<code>PATH_MAX</code>作为<code>FILENAME_MAX</code>更好的替代</p>
</li>
<li>
<p><code>read</code>系统调用原来的接口是</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nbytes</span><span class="p">);</span>
</span></span></code></pre></div><p>ISO C要求泛型数据应该使用<code>void*</code>，于是<code>char* buf</code>被改成了<code>void* buf</code><br>
POSIX.1 引入了<code>size_t</code>表示数据的大小，于是<code>unsigned bytes</code>变成了<code>size_t nbytes</code><br>
此外POSIX.1还引入了<code>ssize_t</code>作为<code>size_t</code>的有符号版本，以支持负数，<code>read</code>的返回值类型也被改成<code>ssize_t</code></p>
<p>最终的版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
</span></span></code></pre></div></li>
</ol>
<p>为了使自己的程序能够在迁移到POSIX兼容机上，以上标准提供了一系列的机制以供开发POSIX兼容的程序</p>
<ol>
<li><code>limit</code>分为编译时<code>limit</code>，运行时<code>limit</code>，编译时<code>limit</code>是编译时常量，可以在编译时期通过引入诸如<code>&lt;limit.h&gt;</code>获取，运行时<code>limit</code>可以由诸如配置文件，命令行，系统调用等方式动态的改变，需要在运行时动态获取
涉及的函数有<code>sysconf</code>, <code>pathconf</code>, <code>fpathconf</code></li>
<li>不同系统对POSIX的支持程度不一样，POSIX提供一系列Feature test macros供开发者检测POSIX特性的支持，并对不同的支持情况作出反应（使用#ifdef条件编译），这种方法只能处理编译时<code>limit</code></li>
</ol>
<h1 id="标准与扩展" class="headerLink">
    <a href="#%e6%a0%87%e5%87%86%e4%b8%8e%e6%89%a9%e5%b1%95" class="header-mark"></a>标准与扩展</h1><p>Unix，C/C++，Web都是多家vendor，一个标准。vendor往往为了自己的利益，或者自己的需要，提供超过标准要求的功能，并推进这些功能加入标准<br>
这一方面是因为标准往往为了中立而非常谨慎，甚至有时候可以说是不作为，导致标准提供的功能不足以覆盖部分需求，另一方面，编译器的vendor往往也是操作系统的vendor，例如Microsft的Windows和Visual c++，Apple的iOS,MacOS和clang，以及GNU与Linux。造操作系统是一个非常艰巨的任务，vendor往往也会造自己的编译器以满足开发操作系统的需求</p>
<p>举一个我打数据库比赛时遇到的情况，我希望对记录进行排序，记录为一块内存，大小在运行时获得，比较函数取出记录中的属性（基址+偏移，数据类型长度）然后比较属性大小，要使用哪个属性参与比较，也是运行时动态取得的
，考虑cpp提供的<code>std::sort</code>，它的数据长度依赖于类型，而类型是编译常量，所以无法做到。考虑来自C的<code>std::qsort</code>，它的原型如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">qsort</span><span class="p">(</span><span class="kt">void</span> <span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compar</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span> <span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="p">))</span>
</span></span></code></pre></div><p>因为比较函数<code>compar</code>是函数指针，无法使用lambda函数捕获外部变量，也就是说每次sql执行时，<code>compar</code>函数行为都是一样的，这肯定不能满足需求，不能实现比较任意属性</p>
<p>我最终使用的是<code>qsort_r</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">qsort_r</span><span class="p">(</span><span class="kt">void</span> <span class="n">base</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nmemb</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">compar</span><span class="p">)(</span><span class="k">const</span> <span class="kt">void</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">),</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</span></span></code></pre></div><p>这是glibc提供的C标准的GNU扩展，也就是说只有glibc才有，换而言之只能在linux使用（关于OS, libc以后有机会单独讲）
这个函数传入一个额外的<code>void *arg</code>，然后它将<code>arg</code>作为第三个参数传入<code>compar</code>，就能实现动态的比较属性</p>
<p>如何使用<code>qsort_r</code>？</p>
<p>因为<code>qsort_r</code>是GNU扩展，man手册如是描述</p>
<blockquote>
<p>Feature Test Macro Requirements for glibc (see feature_test_macros(7)):</p>
<pre><code> qsort_r():
     _GNU_SOURCE
</code></pre>
</blockquote>
<p>要使用<code>qsort_r</code>，首先要定义<code>_GNU_SOURCE</code>，然后引入声明了<code>qsort_r</code>的头文件<code>&lt;stdlib.h&gt;</code></p>
<p>然后查看gcc预定义的宏</p>
<pre tabindex="0"><code>➜  bin git:(p6-merge-join) ✗  echo | g++ -dM -E -x c++ - | grep _GNU_SOURCE
#define _GNU_SOURCE 1
</code></pre><p>可以看到我的gcc已经定义了，也就是默认启动了GNU扩展，所以直接引入<code>&lt;stdlib.h&gt;</code>即可，无需额外操作<br>
然而其他版本的gcc也许没有预先定义，最优解法是在编译时通过命令行参数定义</p>
<p>以上例子可以看出标准往往是保守的，从Visual C++的各种<code>_s</code>版本函数可以也看出来这点</p>
<hr>
<p><figure><a class="lightgallery" href="https://raw.githubusercontent.com/z2z63/image/main/202406172243329.png" title="https://raw.githubusercontent.com/z2z63/image/main/202406172243329.png" data-thumbnail="https://raw.githubusercontent.com/z2z63/image/main/202406172243329.png">
        <img
            
            loading="lazy"
            src="https://raw.githubusercontent.com/z2z63/image/main/202406172243329.png"
            srcset="https://raw.githubusercontent.com/z2z63/image/main/202406172243329.png, https://raw.githubusercontent.com/z2z63/image/main/202406172243329.png 1.5x, https://raw.githubusercontent.com/z2z63/image/main/202406172243329.png 2x"
            sizes="auto"
            alt="https://raw.githubusercontent.com/z2z63/image/main/202406172243329.png">
    </a></figure>
Visual C++的<code>_s</code>系列函数，例如<code>scanf_s</code>，<code>strcpy_s</code>,<code>sprintf</code>，是标准库对应函数的安全版本(security)，主要解决了buffer overflow问题，这些函数是visual c++的独占特性（或windows的独占特性），但是作为C标准的扩展进入了C标准，开发者可以在只引入标准库提供的头文件的情况下使用他们，在将别人的程序迁移至其他平台时造成了不少的麻烦！</p>
<blockquote>
<p><strong><em>NOTE:</em></strong> 如果对以上内容感兴趣，参见APUE(《Unix环境高级编程》)</p>
</blockquote>
</div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>Updated on 2024-06-17</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share"></div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">Back</a></span>&nbsp;|&nbsp;<span><a href="/">Home</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/browser_tricks/" class="prev" rel="prev" title="浏览器小技巧总结"><i class="fas fa-angle-left fa-fw"></i>浏览器小技巧总结</a>
            <a href="/posts/week2/" class="next" rel="next" title="第二周：败者树、范式与反范式">第二周：败者树、范式与反范式<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    Powered by <a href="https://gohugo.io/" target="_blank" rel="noopener noreferrer" title="Hugo 0.127.0">Hugo</a>&nbsp;|&nbsp;Theme - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreferrer" title="DoIt 0.4.0"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer"></a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="Back to Top">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="View Comments">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><link rel="stylesheet" href="/lib/gitalk/gitalk.min.css"><script type="text/javascript">window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":10},"comment":{"gitalk":{"admin":["z2z63"],"clientID":"7156e4335b80dc5f38c0","clientSecret":"f6118f46792df390e800c05b52300a8da0114474","id":"2024-06-17T19:36:40+08:00","owner":"z2z63","repo":"z2z63.github.io","title":"Week1"}}};</script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/js/theme.min.js" defer></script><script type="text/javascript" src="/lib/gitalk/gitalk.min.js"></script><script type="text/javascript" src="/js/gitalk.min.js" defer></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'G-48XH0QHHK3');
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=G-48XH0QHHK3" async></script></div>
</body>

</html>