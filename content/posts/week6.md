---
title: "第六周：关于C/C++开发，我了解的一切 —— 编译器、构建工具"
author: z2z63
date: 2024-07-20T20:59:10+08:00
---

最近两个月也是基本一直在写C++了，尤其是实习以来，从一个linux的C++开发者切换到windows + visual c++，这其中遇到的问题非常多，也让我不断的思考究竟怎样才是最佳实践。  

此外，实习期间摸鱼时，也阅读了不少python源码，为了理解python的内存管理系统，还翻了四五遍glibc的wiki，粗略看了`malloc`源码，也算是学到了不少知识，为了分享这些知识，我决定先将我从各种项目中学习到的C/C++开发应该了解的知识系统总结一下

## 前置概念
- C/C++是系统开发语言，绝大部分操作系统的系统调用都是以C/C++的API形式提供的
- C++不应该被视为一种语言，而是一个松散的语言联邦。可以认为GNU的C++是gnu-cpp语言，而Microsoft的C++是visual-cpp语言。而这些xxx-cpp语言恰好满足了一个名为C++的语言联邦的约定，于是都称为C++
- 接上，以上观点的原因是，不同平台的C++开发区别实在是太大了。Windows的C++开发者和Linux的C++开发者表面上都在开发C++，但是他们的考虑到底层的方式，使用的工具，使用工具的方式都是截然不同的。例如同一个`printf`，linux的C++开发者会想到文件描述符，会想到tty等等，而Windows的C++开发者会想到Win32 API，会想到回车换行符，会想到控制台主机等等
- C++开发者在跨平台时，需要能够跨CPU架构、操作系统、libc++实现、编译器
- undefined behavior（UB）,即未定义行为，指C++标准明确规定此行为的结果不确定，UB不是未文档的行为
- implementation-defined behavior（IB），即实现定义行为，指C++标准规定此类行为的结果应该由C++实现（通常是编译器vendor）规定
- UB，IB的行为往往是根据当前架构，当前实现方式中选取的性能最好的一种行为，即C++跨平台时需要考虑避免UB和IB

## 工具链
为了将源码转变为最终的二进制，需要编译器、汇编器、链接器、调试器共同工作  
此外，往往还需要配套的构建工具例如makefile、cmake等，他们共同组成了C++工具链

工具链往往跟平台有关，linux往往使用GCC工具链中的`gcc`作为编译器，`as`作为汇编器，`ld`作为链接器，`gdb`作为调试器

此外，一套工具链中的工具是相互协作，共同生成二进制。例如gcc会在编译时，将一些信息嵌入ELF某些段中，指示`ld`如何工作，因此gcc编译的中间产物不能被其他链接器使用，不同平台的汇编代码也不同，例如GCC的汇编器是`GAS`(GNU Assember)，其语法与visual c++的汇编器`MASM`不同。因此，生成二进制产物必须由一套工具链的工具相互协作，不能混用工具链

对于传统开源项目，常常使用GNU的autotools，makeilfe作为构建工具。对于现代C++项目，通常使用CMake作为构建工具，CMake在linux平台往往使用makefile完成最终的构建；而windows可以选择microsoft提供的visual c++工具链，并使用Visual Studio进行开发，Visual Studio往往会调用`msbuild`或`nmake`完成构建

## 编译参数
编译参数即传给编译器的参数。广义的编译参数包括任何字面上传递的参数，狭义的编译参数指一些控制编译器行为的标志，而不包括诸如头文件搜索路径，源文件路径等等

以gcc为例，编译参数一般有一下部分
- 头文件搜索路径
- 源文件路径
- 输出产物路径
- 优化参数
  所谓优化，即将一段代码转为效率更高，但是结果等价的代码  
  优化参数通常为`-f`开头，用于控制是否开启某项编译优化手段  
  此外，还提供了`-O0`，`-O1`，`-O2`，`-O3`方便使用，会分别批量打开对应的优化开关
  `-O0`表示关闭所有开关，而`-O3`表示开启所有开关  
  常使用O2而不使用O3，原因如下
  - 在gcc历史上有段时期O3并不稳定
  - O3的优化结果的等价性更依赖于无UB，大部分开发者无法避免写出无UB的程序，O3优化容易使得这些程序出现错误
  - O2已经提供了足够使用的优化
  - O3优化在进行循环展开时，可能导致循环体超过cache line的大小，反而降低速度
  - O3优化可能利用当前平台特性，可能导致二进制产物无法在其他平台运行
- 功能参数
- 警告参数
  通常`-W`开头，用于单独控制是否对某个行为发出警告  
  如果抑制警告，通常是`-Wno`开头  
  `-Wall`表示开启所有警告，常用于避免潜在的问题
  `-Werror`表示将警告转为错误，在比较严格的场合下用于强制开发者消除所有警告
- 语言特定参数
- 诊断参数
- 静态分析参数
- 代码生成参数
  用于控制输出的二进制产物，例如`-fPIC`控制生成地址无关代码，常用于生成共享对象
- 链接器参数
  gcc会在内部调用`ld`，链接器参数会直接传递给`ld`
- 汇编器参数
  同理，gcc会在内部调用`as`，链接器参数会直接传递给`as`
- 宏定义参数
  部分宏定义需要在编译时传入，以控制程序的行为

## 如何编译
大部分场合下，编译时需要指定的编译参数如下
- 头文件搜索路径
- 库搜索路径
- 优化参数
- 调试参数
- 宏定义参数

对于一个单文件，可以在shell中输入编译命令，快速完成编译  
对于C/C++工程，手动输入编译命令非常繁琐，在“古代”的方法是使用shell脚本记录编译的命令，问题如下
- 大型项目构建时间非常长，仅仅修改一个文件也需要重新完成整个工程的编译
- 如果需要传入参数以控制编译行为，脚本就会变得越来越复杂

## Makefile
Makefile就是为了解决以上问题而出现的，它可以认为是shell脚本的一种封装  
Makefile有以下内容：
- 规则  
  规则告诉Makefile如何生成target  
  规则分为显式规则和隐式规则，显式规则组成如下
  - target  
    通常是输出产物的路径名，即一个规则会产生文件，使用伪target可以定义不产生文件的规则
  - prerequisites  
    执行规则前应当满足的先决条件
  - recipe  
    规则如何执行，会交给shell解释执行
- 变量定义
- 其他指令
  例如`include`指令可以引入其他Makefile文件

makefile的隐式规则可以节省非常多的代码，例如
- `aaa.o`如果没有对应的规则可以生成，Makefile会自动应用隐式规则，将`aaa.c`编译得到`aaa.o`
- `CC`为默认的C编译器，`CXX`为默认的C++编译器
- `CFLAGS`为默认编译时，传递给`CC`的编译参数，同理`CXXFLAGS`是默认传递给`CXX`的编译参数

## autotools
C的一个特点是利用宏定义和条件编译，可以控制参与编译的代码，做到适应各种平台，例如
- 跨平台软件实现子进程时，利用条件编译可以在不同的平台调用相应的系统调用
  ```c
  #ifdef LINUX
  // fork ...
  #endif

  #ifdef WIN32
  // CreateProcess...
  #endif
  ```
  注意一般只有标准库没有提供的功能才有必要使用这种方法，例如读写文件就可以直接使用标准库
- 实现一个高性能的HTTP服务器时往往使用`epoll`，但内核版本比较旧的linux系统没有`epoll`，可以使用其下位替代`select`
  ```c
  #ifdef HAVE_EPOLL
  // epoll...
  #else
  // select
  #endif
  ```
- C标准没有规定如何控制符号导出，为了导出动态库，可以在windows平台使用visual c++的扩展`__declspec(dllexport)`，在linux平台可以使用GNU扩展`__attribute__((visibility("default")))`  
  ```c
  #ifdef LINUX
  #define MYEXPORT __attribute__((visibility("default")))
  #endif

  #ifdef WIN32
  #define MYEXPORT __declspec(dllexport)
  #endif
  ```

所以一个C/C++项目在build之前往往还有configure的步骤，configure识别当前平台、工具链，并允许设置一些功能开关，供用户裁剪功能，configure的产物是一堆用户定义的宏和变量，用于传入构建系统。autotools完成的就是configrue的工作  

autotools非常复杂，基于非常原始的文本替换，而且只能在linux平台使用，并不推荐学习autotools，只需要掌握如何使用autotools的`configure`即可

autotools给编译者（一般区别于开发者）提供的接口为`configure`，它是一个在项目根目录的具有执行权限的脚本，一般用法如下
```shell
CFLAGS=-O2 -g ../configure --prefix=/home/arch/xxx
```
`configure`提供的开关由开发者定义，需要使用`../configure --help`查看支持的所有开关  
`CFLAGS`通常作为环境变量传入`configure`，随后`configure`将参数嵌入生成的`Makefile`中  
`--prefix`一般用于指定安装目录，默认安装目录`/usr/local`需要root权限，也可以手动指定一个无特权目录

autotools虽然本身的概念非常晦涩，从设计上来说也不好用，但许多大型开源项目都使用了autotools，原因如下
- 大部分使用autotools的项目都是历史悠久的老牌开源项目，当时只有autotools可选
- autotools是GNU三板斧之一，GNU认为自由软件构建所需的工具链也得是自由的
  
## 树外构建
大部分构建工具都会缓存构建中间产物以加快构建速度，套用本博客的文章[《第二周：败者树、范式与反范式》](../week2#唯一事实原则)的观点，构建中间产物是cache，它违反了唯一事实原则。其后果是在某些情况下，中间产物可能不是最新的，这时需要强制清空所有构建产物，执行一次干净的构建。因此，构建工具往往提供`clean`的功能

如果将源文件在文件系统中的分布看作源码树，那么直接在项目根目录进行构建，构建的中间产物就会和源码树混杂在一起，这样的构建被称为树内构建，在`clean`时，需要深入源码树每个层级，精准删除构建中间产物而不删除源文件。Makefile的`clean`目标一般是使用`find`命令实现的

构建的中间产物就会和源码树混杂在一起后，会产生如下问题
- 使得`clean`操作变得复杂（甚至部分项目无法保证彻底`clean`，例如glibc）
- 开发时大量无关文件和源文件混杂，影响效率

鉴于树内构建的问题，通常使用树外构建，即创建一个目录（通常为`build`），进入此目录进行构建。构建后，输出的构建中间产物和最终产物都在`build`目录内，clean时不必担心误删源文件

autotools + Makefile的树外构建流程如下
1. 新建一个目录用于构建并进入该目录
   ```shell
   mkdir build
   cd build
   ```
2. 完成configure
   ```shell
   ../configure
   ```
3. 构建
   ```shell
   make
   ```
---
未完待续