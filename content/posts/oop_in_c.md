---
title: "Oop_in_c"
author: z2z63
date: 2024-04-12T15:31:31+08:00
draft: true
---



---



这篇文章总结了如何使用C实现面向对象编程(OOP)

众所周知面向对象有三大特征：封装、继承、多态

如果考虑自己实现一个编译器或解释器，这三个特征是在不同时期内完成的

- 封装

  封装简单来说，是阻止外部调用类的私有方法，在传统OOP语言例如java中，有`private`，`public`，`protect`，此外当没有使用权限修饰符时还有一个默认的权限即包内可见。在其他语言中，为了降低复杂度，减少低频关键字，已经很少使用java这种如此精细又复杂的权限控制了，例如python约定`_`开头的方法或属性为私有，不希望外部调用（但不阻止），go规定首字母大写为共有，dart规定下划线开头为私有

  由此可见所谓封装，可以是强制的，由编译器拒绝访问私有属性，也可以是约定的，允许访问私有属性但风险自己承担

  因此，封装是一个可以在编译时完成的工作，也可以完全不提供语言特性而只靠约定

- 继承

  所谓继承，是一种提高代码复用率的方法，子类继承父类时，自动获得父类的方法和属性。子类继承父类方法时，不仅仅复用了代码，也复用了方法编译后产生的机器指令，这主要是编译器完成的工作

- 多态

  所谓多态，可以认为是可以将任何子类对象完美的替代父类对象的位置，为了实现这一点，一定要将类型信息带入运行时。这也是OOP带来的一个运行时开销(runtime overhead)

  此外，需要验证当前提供的对象是子类对象而不是其他对象，需要将子类与父类的继承关系也带入运行时



## C实现封装

如上讨论，C实现的封装主要靠约定，这一点与python很相似

此外，C还能使用`static`修饰函数，代表此函数只能在当前文件使用，也能起到一定的封装作用

## C实现继承

假设有一个父类`Object`

```c
typedef int(*VoidCallback)();
struct Object{
    int a,
    int b,
    VoidCallback c;
    //...
}
```

创建一个子类

```c
struct Child{
    struct Object o,
    int a，
    int d,
    VoidCallback e,
}
```



即可自动继承父类的所有方法和属性。通过`child->o->xxx`即可访问父类方法和属性

## C实现多态

以上C实现继承的方法也能实现多态，这基于`struct`的汇编实现：

所谓`struct`就是将各种单值（标量）聚合起来，形成一个连续的比特序列，通过基址 + 各字段的偏移值访问

`struct Object o`必须是`Child`的第一个字段，因为`o`的偏移值是`0`，生成汇编代码后，访问`o`即`child`地址+`0`，即`child`基址

如果需要访问父类方法或属性

```c
((Object*) child)->a
```

如果需要访问子类的方法或属性

```c
child->a
```

指针类型转换只对编译器有作用，在汇编层面不会生成任何汇编代码

以上说明了`child`指针可以当`Child`类用，也能当`Object`类用，但能自由调用子类和父类方法的前提是指定子类的类型名，然而很多时候是不能知道，或者不能对对象的运行时类型作出假定



前文提及实现多态一定要将类型带入运行时，现在尝试为`Object`加上类型信息

```c
struct Object{
    int a,
    int b,
    int type = 1,
    VoidCallback c;
    //...
}
```

`type`可以是对象类型的枚举

在使用父类对象的地方可以先判断`type`字段，然后指针转型，再访问属性或方法

```c
void func(Object* o){
    int a;
    VoidCallback c;
    if(o->type == 1){
        a = o->a;
        c = o->c;
    }else if(o->type == 2){
        Child* child = (Child*) o;
        a = o->a;
        c = o->e;
    }else{
        // invliad
    }
}
```

